{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","state","selection","_this2","this","fetch","props","dataset","url","then","response","json","data","edges","map","x","id","label","source","target","classes","nodes","setState","elements","schema","console","log","catch","err","loaded","build","_this3","cy","cytoscape","container","document","getElementById","boxSelectionEnabled","autounselectify","minZoom","maxZoom","style","stylesheet","selector","css","height","width","background-fit","background-color","border-color","font-size","border-width","border-opacity","text-valign","target-arrow-shape","line-color","target-arrow-color","curve-style","edge-text-rotation","layout","name","on","event","targetLabel","i","length","vertices","cyStyle","margin","borderStyle","borderColor","borderWidth","react_default","a","createElement","main_default","src","enableClipboard","displayDataTypes","Component","Boolean","window","location","hostname","match","run","ReactDOM","render","src_App_0","addEventListener","attachEvent","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.d99d9888.chunk.js","sourcesContent":["import cytoscape from \"cytoscape\";\nimport React, { Component } from 'react';\nimport ReactJson from 'react-json-view';\nimport './App.css';\n\nclass App extends Component {\n\n  state = {\n    selection: {},\n  }\n\n  componentDidMount() {\n    fetch(this.props.dataset.url)\n      .then(response => response.json())\n      .then(data => {\n        var edges = data[\"edges\"].map(function(x){\n          return {\n            \"data\": {\n              \"id\": x[\"label\"] + x[\"from\"] + x[\"to\"], \n              \"label\": x[\"label\"], \n              \"source\": x[\"from\"], \n              \"target\": x[\"to\"]\n            }, \n            \"classes\": \"autorotate\"\n          }\n        })\n\n        var nodes = data[\"vertices\"].map(function(x){\n          return {\"data\": {\"id\": x[\"label\"]}}\n        })\n          \n        this.setState({elements: {\"nodes\": nodes, \"edges\": edges}, schema: data})\n        console.log(\"Loaded the graph schema...\",)\n      }).catch(err => {\n        console.log(\"Failed to load the graph schema:\", this.props.dataset.url, \":\", err)\n      })\n  }\n\n  componentDidUpdate() {\n    if (!this.state.loaded) {\n  \t  this.build();\n    }\n  }\n\n  build() {\n    console.log(\"Cytoscape.js is rendering the graph...\");\n\n    var cy = cytoscape(\n      {\n        container: document.getElementById(\"cy\"),\n\n        boxSelectionEnabled: false,\n        autounselectify: false,\n\n        minZoom: 0.1,\n        maxZoom: 10,\n\n        elements: this.state.elements,\n\n        style: cytoscape.stylesheet()\n          .selector(\"node\")\n          .css({\n            \"height\": 80,\n            \"width\": 80,\n            \"background-fit\": \"cover\",\n            'background-color': \"#bcbcbc\",\n            \"border-color\": \"#bcbcbc\",\n            \"font-size\": \"14px\",\n            \"border-width\": 3,\n            \"border-opacity\": 1,\n            \"text-valign\": \"center\",\n            \"label\": \"data(id)\"\n          })\n          .selector(\"node:selected\")\n          .css({\n            'background-color': \"#4286f4\",\n            \"border-color\": \"#4286f4\",\n          })\n          .selector(\"edge\")\n          .css({\n            \"width\": 6,\n            \"target-arrow-shape\": \"triangle\",\n            \"line-color\": \"#ffaaaa\",\n            \"target-arrow-color\": \"#ffaaaa\",\n            \"curve-style\": \"bezier\",\n            \"label\": \"data(label)\"\n          })\n          .selector(\"edge:selected\")\n          .css({\n            \"line-color\": \"#4286f4\",\n            \"target-arrow-color\": \"#4286f4\",\n          })\n          .selector(\".autorotate\")\n          .css({\n            \"edge-text-rotation\": \"autorotate\"\n          }),\n\n        layout: {\n          name: \"cose\"\n        }\n      }\n    );\n\n    cy.on('tap', 'edge', event => {\n      var targetLabel = event.target.data().label\n      var data = {}\n      for (var i = 0; i < this.state.schema.edges.length; i++) {\n        if (this.state.schema.edges[i].label === targetLabel) {\n          data = this.state.schema.edges[i]\n        }\n      }\n      this.setState({ selection: data });\n    })\n    cy.on('tap', 'node', event => {\n      var targetLabel = event.target.data().id\n      var data = {}\n      for (var i = 0; i < this.state.schema.vertices.length; i++) {\n        if (this.state.schema.vertices[i].label === targetLabel) {\n          data = this.state.schema.vertices[i]\n        }\n      }\n      this.setState({ selection: data });\n    })\n    this.cy = cy;\n    this.setState({ loaded: true });\n  }\n\n  render() {\n    let cyStyle = {\n      height: this.props.dataset.height,\n      width: this.props.dataset.width,\n      margin: \"5px auto\",\n      borderStyle: \"solid\",\n      borderColor: \"#D3D3D3\",\n      borderWidth: \"thin\"\n    };\n    return (\n      <div>\n        <div style={cyStyle} id=\"cy\"></div>\n        <div style={{width: this.props.dataset.width, margin: \"5px auto\"}} id=\"reactJson\">\n          <ReactJson src={this.state.selection} name={false}  enableClipboard={false} displayDataTypes={false}/>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nfunction run() {\n  // get div where Graph should be rendered\n  const schema = document.getElementById('schema')\n  if (schema) {\n    // get parameters set by caller on element data-* attributes\n    const dataset = schema.dataset;\n    console.log(\"schema\", schema);\n    ReactDOM.render(<App dataset={dataset}/>, schema);\n  }\n}\n\n// mount react on page load\nif (window.addEventListener) {\n  window.addEventListener('DOMContentLoaded', run);\n} else {\n  window.attachEvent('onload', run);\n}\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}